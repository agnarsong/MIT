/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type { FunctionFragment, Result } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../../../common";

export declare namespace BN254 {
  export type G1PointStruct = {
    X: PromiseOrValue<BigNumberish>;
    Y: PromiseOrValue<BigNumberish>;
  };

  export type G1PointStructOutput = [BigNumber, BigNumber] & {
    X: BigNumber;
    Y: BigNumber;
  };

  export type G2PointStruct = {
    X: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>];
    Y: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>];
  };

  export type G2PointStructOutput = [
    [BigNumber, BigNumber],
    [BigNumber, BigNumber]
  ] & { X: [BigNumber, BigNumber]; Y: [BigNumber, BigNumber] };
}

export declare namespace DataLayrDisclosureLogic {
  export type DataStoreKZGMetadataStruct = {
    c: BN254.G1PointStruct;
    degree: PromiseOrValue<BigNumberish>;
    numSys: PromiseOrValue<BigNumberish>;
    numPar: PromiseOrValue<BigNumberish>;
  };

  export type DataStoreKZGMetadataStructOutput = [
    BN254.G1PointStructOutput,
    number,
    number,
    number
  ] & {
    c: BN254.G1PointStructOutput;
    degree: number;
    numSys: number;
    numPar: number;
  };

  export type MultiRevealProofStruct = {
    interpolationPoly: BN254.G1PointStruct;
    revealProof: BN254.G1PointStruct;
    zeroPoly: BN254.G2PointStruct;
    zeroPolyProof: PromiseOrValue<BytesLike>;
  };

  export type MultiRevealProofStructOutput = [
    BN254.G1PointStructOutput,
    BN254.G1PointStructOutput,
    BN254.G2PointStructOutput,
    string
  ] & {
    interpolationPoly: BN254.G1PointStructOutput;
    revealProof: BN254.G1PointStructOutput;
    zeroPoly: BN254.G2PointStructOutput;
    zeroPolyProof: string;
  };
}

export interface DataLayrDisclosureLogicInterface extends utils.Interface {
  functions: {
    "getDataCommitmentAndMultirevealDegreeAndSymbolBreakdownFromHeader(bytes)": FunctionFragment;
    "getLeadingCosetIndexFromHighestRootOfUnity(uint32,uint32,uint32)": FunctionFragment;
    "getZeroPolyMerkleRoot(uint256)": FunctionFragment;
    "linearPolynomialEvaluation(bytes,uint256)": FunctionFragment;
    "nextPowerOf2(uint256)": FunctionFragment;
    "nonInteractivePolynomialProof(bytes,uint32,bytes,((uint256,uint256),(uint256,uint256),(uint256[2],uint256[2]),bytes),(uint256[2],uint256[2]))": FunctionFragment;
    "openPolynomialAtPoint((uint256,uint256),(uint256[2],uint256[2]),uint256,uint256)": FunctionFragment;
    "reverseBits(uint32)": FunctionFragment;
    "reverseBitsLimited(uint32,uint32)": FunctionFragment;
    "validateDisclosureResponse(((uint256,uint256),uint48,uint32,uint32),uint32,(uint256,uint256),(uint256,uint256),(uint256[2],uint256[2]),bytes)": FunctionFragment;
    "verifyBatchPolyEquivalenceProof(bytes[],(uint256,uint256)[],(uint256[2],uint256[2]))": FunctionFragment;
    "verifyPolyEquivalenceProof(bytes,(uint256,uint256),(uint256[2],uint256[2]))": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "getDataCommitmentAndMultirevealDegreeAndSymbolBreakdownFromHeader"
      | "getLeadingCosetIndexFromHighestRootOfUnity"
      | "getZeroPolyMerkleRoot"
      | "linearPolynomialEvaluation"
      | "nextPowerOf2"
      | "nonInteractivePolynomialProof"
      | "openPolynomialAtPoint"
      | "reverseBits"
      | "reverseBitsLimited"
      | "validateDisclosureResponse"
      | "verifyBatchPolyEquivalenceProof"
      | "verifyPolyEquivalenceProof"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "getDataCommitmentAndMultirevealDegreeAndSymbolBreakdownFromHeader",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "getLeadingCosetIndexFromHighestRootOfUnity",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getZeroPolyMerkleRoot",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "linearPolynomialEvaluation",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "nextPowerOf2",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "nonInteractivePolynomialProof",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      DataLayrDisclosureLogic.MultiRevealProofStruct,
      BN254.G2PointStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "openPolynomialAtPoint",
    values: [
      BN254.G1PointStruct,
      BN254.G2PointStruct,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "reverseBits",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "reverseBitsLimited",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "validateDisclosureResponse",
    values: [
      DataLayrDisclosureLogic.DataStoreKZGMetadataStruct,
      PromiseOrValue<BigNumberish>,
      BN254.G1PointStruct,
      BN254.G1PointStruct,
      BN254.G2PointStruct,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "verifyBatchPolyEquivalenceProof",
    values: [
      PromiseOrValue<BytesLike>[],
      BN254.G1PointStruct[],
      BN254.G2PointStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "verifyPolyEquivalenceProof",
    values: [
      PromiseOrValue<BytesLike>,
      BN254.G1PointStruct,
      BN254.G2PointStruct
    ]
  ): string;

  decodeFunctionResult(
    functionFragment: "getDataCommitmentAndMultirevealDegreeAndSymbolBreakdownFromHeader",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getLeadingCosetIndexFromHighestRootOfUnity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getZeroPolyMerkleRoot",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "linearPolynomialEvaluation",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "nextPowerOf2",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "nonInteractivePolynomialProof",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "openPolynomialAtPoint",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "reverseBits",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "reverseBitsLimited",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "validateDisclosureResponse",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "verifyBatchPolyEquivalenceProof",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "verifyPolyEquivalenceProof",
    data: BytesLike
  ): Result;

  events: {};
}

export interface DataLayrDisclosureLogic extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: DataLayrDisclosureLogicInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    getDataCommitmentAndMultirevealDegreeAndSymbolBreakdownFromHeader(
      header: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[DataLayrDisclosureLogic.DataStoreKZGMetadataStructOutput]>;

    getLeadingCosetIndexFromHighestRootOfUnity(
      i: PromiseOrValue<BigNumberish>,
      numSys: PromiseOrValue<BigNumberish>,
      numPar: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[number]>;

    getZeroPolyMerkleRoot(
      degree: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    linearPolynomialEvaluation(
      poly: PromiseOrValue<BytesLike>,
      r: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    nextPowerOf2(
      n: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    nonInteractivePolynomialProof(
      header: PromiseOrValue<BytesLike>,
      chunkNumber: PromiseOrValue<BigNumberish>,
      poly: PromiseOrValue<BytesLike>,
      multiRevealProof: DataLayrDisclosureLogic.MultiRevealProofStruct,
      polyEquivalenceProof: BN254.G2PointStruct,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    openPolynomialAtPoint(
      c: BN254.G1PointStruct,
      pi: BN254.G2PointStruct,
      r: PromiseOrValue<BigNumberish>,
      s: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    reverseBits(
      value: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[number]>;

    reverseBitsLimited(
      length: PromiseOrValue<BigNumberish>,
      value: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[number]>;

    validateDisclosureResponse(
      dskzgMetadata: DataLayrDisclosureLogic.DataStoreKZGMetadataStruct,
      chunkNumber: PromiseOrValue<BigNumberish>,
      interpolationPoly: BN254.G1PointStruct,
      revealProof: BN254.G1PointStruct,
      zeroPoly: BN254.G2PointStruct,
      zeroPolyProof: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    verifyBatchPolyEquivalenceProof(
      polys: PromiseOrValue<BytesLike>[],
      interpolationPolys: BN254.G1PointStruct[],
      polyEquivalenceProof: BN254.G2PointStruct,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    verifyPolyEquivalenceProof(
      poly: PromiseOrValue<BytesLike>,
      interpolationPoly: BN254.G1PointStruct,
      polyEquivalenceProof: BN254.G2PointStruct,
      overrides?: CallOverrides
    ): Promise<[boolean]>;
  };

  getDataCommitmentAndMultirevealDegreeAndSymbolBreakdownFromHeader(
    header: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<DataLayrDisclosureLogic.DataStoreKZGMetadataStructOutput>;

  getLeadingCosetIndexFromHighestRootOfUnity(
    i: PromiseOrValue<BigNumberish>,
    numSys: PromiseOrValue<BigNumberish>,
    numPar: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<number>;

  getZeroPolyMerkleRoot(
    degree: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  linearPolynomialEvaluation(
    poly: PromiseOrValue<BytesLike>,
    r: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  nextPowerOf2(
    n: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  nonInteractivePolynomialProof(
    header: PromiseOrValue<BytesLike>,
    chunkNumber: PromiseOrValue<BigNumberish>,
    poly: PromiseOrValue<BytesLike>,
    multiRevealProof: DataLayrDisclosureLogic.MultiRevealProofStruct,
    polyEquivalenceProof: BN254.G2PointStruct,
    overrides?: CallOverrides
  ): Promise<boolean>;

  openPolynomialAtPoint(
    c: BN254.G1PointStruct,
    pi: BN254.G2PointStruct,
    r: PromiseOrValue<BigNumberish>,
    s: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  reverseBits(
    value: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<number>;

  reverseBitsLimited(
    length: PromiseOrValue<BigNumberish>,
    value: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<number>;

  validateDisclosureResponse(
    dskzgMetadata: DataLayrDisclosureLogic.DataStoreKZGMetadataStruct,
    chunkNumber: PromiseOrValue<BigNumberish>,
    interpolationPoly: BN254.G1PointStruct,
    revealProof: BN254.G1PointStruct,
    zeroPoly: BN254.G2PointStruct,
    zeroPolyProof: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  verifyBatchPolyEquivalenceProof(
    polys: PromiseOrValue<BytesLike>[],
    interpolationPolys: BN254.G1PointStruct[],
    polyEquivalenceProof: BN254.G2PointStruct,
    overrides?: CallOverrides
  ): Promise<boolean>;

  verifyPolyEquivalenceProof(
    poly: PromiseOrValue<BytesLike>,
    interpolationPoly: BN254.G1PointStruct,
    polyEquivalenceProof: BN254.G2PointStruct,
    overrides?: CallOverrides
  ): Promise<boolean>;

  callStatic: {
    getDataCommitmentAndMultirevealDegreeAndSymbolBreakdownFromHeader(
      header: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<DataLayrDisclosureLogic.DataStoreKZGMetadataStructOutput>;

    getLeadingCosetIndexFromHighestRootOfUnity(
      i: PromiseOrValue<BigNumberish>,
      numSys: PromiseOrValue<BigNumberish>,
      numPar: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<number>;

    getZeroPolyMerkleRoot(
      degree: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    linearPolynomialEvaluation(
      poly: PromiseOrValue<BytesLike>,
      r: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    nextPowerOf2(
      n: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    nonInteractivePolynomialProof(
      header: PromiseOrValue<BytesLike>,
      chunkNumber: PromiseOrValue<BigNumberish>,
      poly: PromiseOrValue<BytesLike>,
      multiRevealProof: DataLayrDisclosureLogic.MultiRevealProofStruct,
      polyEquivalenceProof: BN254.G2PointStruct,
      overrides?: CallOverrides
    ): Promise<boolean>;

    openPolynomialAtPoint(
      c: BN254.G1PointStruct,
      pi: BN254.G2PointStruct,
      r: PromiseOrValue<BigNumberish>,
      s: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    reverseBits(
      value: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<number>;

    reverseBitsLimited(
      length: PromiseOrValue<BigNumberish>,
      value: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<number>;

    validateDisclosureResponse(
      dskzgMetadata: DataLayrDisclosureLogic.DataStoreKZGMetadataStruct,
      chunkNumber: PromiseOrValue<BigNumberish>,
      interpolationPoly: BN254.G1PointStruct,
      revealProof: BN254.G1PointStruct,
      zeroPoly: BN254.G2PointStruct,
      zeroPolyProof: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    verifyBatchPolyEquivalenceProof(
      polys: PromiseOrValue<BytesLike>[],
      interpolationPolys: BN254.G1PointStruct[],
      polyEquivalenceProof: BN254.G2PointStruct,
      overrides?: CallOverrides
    ): Promise<boolean>;

    verifyPolyEquivalenceProof(
      poly: PromiseOrValue<BytesLike>,
      interpolationPoly: BN254.G1PointStruct,
      polyEquivalenceProof: BN254.G2PointStruct,
      overrides?: CallOverrides
    ): Promise<boolean>;
  };

  filters: {};

  estimateGas: {
    getDataCommitmentAndMultirevealDegreeAndSymbolBreakdownFromHeader(
      header: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getLeadingCosetIndexFromHighestRootOfUnity(
      i: PromiseOrValue<BigNumberish>,
      numSys: PromiseOrValue<BigNumberish>,
      numPar: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getZeroPolyMerkleRoot(
      degree: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    linearPolynomialEvaluation(
      poly: PromiseOrValue<BytesLike>,
      r: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    nextPowerOf2(
      n: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    nonInteractivePolynomialProof(
      header: PromiseOrValue<BytesLike>,
      chunkNumber: PromiseOrValue<BigNumberish>,
      poly: PromiseOrValue<BytesLike>,
      multiRevealProof: DataLayrDisclosureLogic.MultiRevealProofStruct,
      polyEquivalenceProof: BN254.G2PointStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    openPolynomialAtPoint(
      c: BN254.G1PointStruct,
      pi: BN254.G2PointStruct,
      r: PromiseOrValue<BigNumberish>,
      s: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    reverseBits(
      value: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    reverseBitsLimited(
      length: PromiseOrValue<BigNumberish>,
      value: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    validateDisclosureResponse(
      dskzgMetadata: DataLayrDisclosureLogic.DataStoreKZGMetadataStruct,
      chunkNumber: PromiseOrValue<BigNumberish>,
      interpolationPoly: BN254.G1PointStruct,
      revealProof: BN254.G1PointStruct,
      zeroPoly: BN254.G2PointStruct,
      zeroPolyProof: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    verifyBatchPolyEquivalenceProof(
      polys: PromiseOrValue<BytesLike>[],
      interpolationPolys: BN254.G1PointStruct[],
      polyEquivalenceProof: BN254.G2PointStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    verifyPolyEquivalenceProof(
      poly: PromiseOrValue<BytesLike>,
      interpolationPoly: BN254.G1PointStruct,
      polyEquivalenceProof: BN254.G2PointStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    getDataCommitmentAndMultirevealDegreeAndSymbolBreakdownFromHeader(
      header: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getLeadingCosetIndexFromHighestRootOfUnity(
      i: PromiseOrValue<BigNumberish>,
      numSys: PromiseOrValue<BigNumberish>,
      numPar: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getZeroPolyMerkleRoot(
      degree: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    linearPolynomialEvaluation(
      poly: PromiseOrValue<BytesLike>,
      r: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    nextPowerOf2(
      n: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    nonInteractivePolynomialProof(
      header: PromiseOrValue<BytesLike>,
      chunkNumber: PromiseOrValue<BigNumberish>,
      poly: PromiseOrValue<BytesLike>,
      multiRevealProof: DataLayrDisclosureLogic.MultiRevealProofStruct,
      polyEquivalenceProof: BN254.G2PointStruct,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    openPolynomialAtPoint(
      c: BN254.G1PointStruct,
      pi: BN254.G2PointStruct,
      r: PromiseOrValue<BigNumberish>,
      s: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    reverseBits(
      value: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    reverseBitsLimited(
      length: PromiseOrValue<BigNumberish>,
      value: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    validateDisclosureResponse(
      dskzgMetadata: DataLayrDisclosureLogic.DataStoreKZGMetadataStruct,
      chunkNumber: PromiseOrValue<BigNumberish>,
      interpolationPoly: BN254.G1PointStruct,
      revealProof: BN254.G1PointStruct,
      zeroPoly: BN254.G2PointStruct,
      zeroPolyProof: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    verifyBatchPolyEquivalenceProof(
      polys: PromiseOrValue<BytesLike>[],
      interpolationPolys: BN254.G1PointStruct[],
      polyEquivalenceProof: BN254.G2PointStruct,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    verifyPolyEquivalenceProof(
      poly: PromiseOrValue<BytesLike>,
      interpolationPoly: BN254.G1PointStruct,
      polyEquivalenceProof: BN254.G2PointStruct,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
